This the README file for protocol-buffers, protocol-buffers-descriptors, and hprotoc.
These are three interdependent Haskell packages by Chris Kuklewicz.
This README was updated most recently to reflect version 0.2.1

Questions and answers:

What is this for?  What does it do?  Why?

  It is a pure Haskell re-implementation of the Google code at
http://code.google.com/apis/protocolbuffers/docs/overview.html
  which is "...a language-neutral, platform-neutral, extensible way of serializing structured data for use in communications protocols, data storage, and more."
  Google's project produces C++, Java, and Python code.  This one produces Haskell code.

How well does this Haskell package duplicate Google's project?

  This provides non-mutable messages that ought to be wire-compatible with Google.
  These message support extensions.
  These messages do not support reading or storing unknown fields; these are errors.
  This does not generate anything for Services/Methods.

  Adding support for unknown fields as an option to hprotoc could be done.
  Adding support for services has not been considered.

What is hprotoc?

  The hprotoc part is a executable program which reads ".proto" files and uses the protocol-buffers package to produce a tree of Haskell source files.  The program is called "hprotoc".  Usage is given by the program itself.

What is protocol-buffers?

  The protocol-buffers part is the library which does:

  1) It provides an external API exported by module Text.ProtocolBuffers for users to read and write the binary format and manipulate the message data structures created by hprotoc.
  2) It provides an internal API for the messages to implement these tasks under module Text.ProtocolBuffers.Header

What is protocol-buffers-descriptor?

  1) It uses the protocol-buffers package.
  2) It provides the code generated by hprotoc from "descriptor.proto" under module Text.DescriptorProtos.
  3) This supports hprotoc which is used to describe proto files and the code they will generate.

What is hprotoc?

  1) It uses protocol-buffers and protocol-buffers-descriptor above.
  2) It is a command line tool that reads in ".proto" files and produces Haskell source trees like Google's protoc.

What do I need to compile the code?

  I use ghc (version 6.8.3) and cabal (version 1.2.4.0).

  The dependencies are listed in the .cabal files, and these currently require you to go to hackage.haskell.org and get packages "binary" (I use version 0.4.2) and "utf8-string" (I use 0.3.1.1).

  The hprotoc Lexer.hs is produced from Lexer.x by the alex program (I use version 2.2) which can be downloaded from http://www.haskell.org/alex/ if you edit Lexer.x and need to regenerate Lexer.hs.

  The usual cabal configure/buid/install works for the protocol-buffers library.
  After installing protocol-buffers go into the describe subdirectory and configure/build/install the protocol-buffers-descriptor library.
  After installing protocol-buffers  and protocol-buffers-descriptor go into the hprotoc subdirectory and configure/build/install the hprotoc executable.

  Note: Patches to support other compilers are welcome.

How mature is this code?

  It can write the wire encoding and read it back.  It will soon be tested for interoperability against Google's read/write code.

  hprotoc generates and uses the Text.DescriptorProtos tree from Google "descriptor.proto" file.

  hprotoc has generated code from google/protobuf/unittest.proto and google/protobuf.unittest_import.  These compile after adding hs-boot files TestAllExtensions.hs-boot, TestFieldOrderings.hs-boot, and TestMutualRecursionA.hs-boot to resolve mutual recursion.  The SPARSE_D and SPARSE_E enum values in the original unittest.proto are negative, which is disallowed so I comment those out.  The TestEnumWithDupValue has duplicated values which cause a compilation warning.

Mutual recursion is a problem?

  It is not fully automatic with GHC.  One can start with the Skeleton.hs-boot file (an extra in the source tree) or just write the needed hs-boot files by hand to break the recursion.  This is very similar to the making header files in C with forward declarations.  See the GHC user manual for more.

  Perhaps a future version will generate the needed hs-boot files automatically.  But the effort of add that feature is more than effort of making the hs-boot files manually.

How stable is the API?

  This is the first working release of the code.  I do not promise to keep any of the API but I am lazy so most things will not change.  The reflection capabilities may get improved/altered.  Stricter warnings and error detection may be added.  Code will move between protocol-buffers and hprotoc projects.  The internals of reading from the wire may be improved.

Where is the API documentation?

  Most Haskell API documentation is from Haddock which is problem: I don't have this working on my computer right now.  When I get Haddock sorted out I will generate decent API documentation.

  Chasing the imports of Text.ProtocolBuffers is the simplest way to see the API right now.  Sorry.
