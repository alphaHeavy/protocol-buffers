This the README file for protocol-buffers and hprotoc, which are Haskell packages.
This README was updated most recently to reflect version 0.2.1

Questions and answers:

What is this for?  What does it do?  Why?

  It is a pure Haskell re-implementation of the Google code at
http://code.google.com/apis/protocolbuffers/docs/overview.html
  which is "...a language-neutral, platform-neutral, extensible way of serializing structured data for use in communications protocols, data storage, and more."

How well does this Haskell package duplicate Google's project?

  This provides non-mutable messages that ought to be wire-compatible with Google.
  These message support extensions.
  These messages do not support reading or storing unknown fields; these are errors.

  This generates nothing for Services/Methods.

  Adding support for unknown fields as an option to hprotoc could be done.
  Adding support for services has not been considered.

What is hprotoc?

  The hprotoc part is a executable program which reads ".proto" files and uses the protocol-buffers package to produce a tree of Haskell source files.  The program is called "hprotoc".  Usage is given by the program itself.

What is protocol-buffers?

  The protocol-buffers part is the library which does:

  1) It provides an external API exported by module Text.ProtocolBuffers for users to read and write the binary format and manipulate the message data structures created by hprotoc.
  2) It provides an internal API for the messages to implement these tasks under module Text.ProtocolBuffers.
  3) It provides the code generated by hprotoc from "descriptor.proto" under module Text.DescriptorProtos which is used to describe proto files and the code they will generate.

What do I need to compile the code?

  I use ghc (version 6.8.3) and cabal (version 1.2.4.0).  The usual cabal configure/buid/install works for the protocol-buffers, and then go into the hprotoc sub-directory and configure/build there to make the hprotoc executable.

  The dependencies are listed in the .cabal files, and these currently require you to go to hackage.haskell.org and get packages "binary" (I use version 0.4.2) and "utf8-string" (I use 0.3.1.1).

  Patches to support other compilers are welcome.

How mature is this code?

  It can write the wire encoding and read it back.  It will soon be tested for interoperability against Google's read/write code.

  hprotoc has generated  (via boostrapping by hand) and now uses the Text.DescriptorProtos tree from Google "descriptor.proto" file.

  hprotoc has generated code from google/protobuf/unittest.proto and google/protobuf.unittest_import.  These compile after adding hs-boot files TestAllExtensions.hs-boot, TestFieldOrderings.hs-boot, and TestMutualRecursionA.hs-boot to resolve mutual recursion.

Mutual recursion is a problem?

  It is not fully automatic with GHC.  One can start with the Skeleton.hs-boot file (an extra in the source tree) or just write the needed hs-boot files by hand to break the recursion.  This is very similar to the making header files in C with forward declarations.  See the GHC user manual for more.

  Perhaps a future version will generate the needed hs-boot files automatically.  But the effort of add that feature is more than effort of making the hs-boot files manually.

How stable is the API?

  This is first-working-release code.  I do not promise to keep any of the API but I am lazy so most things will not change. The reflection capabilities may get improved/altered.  Code will move between protocol-buffers and hprotoc projects.

Where is the API documentation?

  Most API documentation is from Haddock which is problem: I don't have this working on my computer right now.  When I get Haddock sorted out I will generate decent API documentation.

  Chasing the imports of Text.ProtocolBuffers is the simplest way to see the API right now.  Sorry.
